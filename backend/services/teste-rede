import os
import pandas as pd
import torch
from torch.utils.data import Dataset
import cv2
# Certifique-se de que o caminho esteja correto
from preprocessing import ImageProcessor


class OpenImagesDataset(Dataset):
    def __init__(self, img_dir, ann_file, class_file, output_dir, image_processor, transform=None):
        self.img_dir = img_dir
        self.annotations = pd.read_csv(ann_file)

        # Filtrar anotações com base nas imagens disponíveis
        img_files = {
            img_file[:-4] for img_file in os.listdir(img_dir) if img_file.endswith('.jpg')}
        self.annotations = self.annotations[self.annotations['ImageID'].isin(
            img_files)]

        # Carregar as classes
        self.class_names = pd.read_csv(class_file, header=None)
        self.class_names.columns = ['LabelName', 'DisplayName']
        self.transform = transform
        self.output_dir = output_dir

        # Criação do diretório de saída, se não existir
        os.makedirs(self.output_dir, exist_ok=True)
        print(f"Diretório {self.output_dir} criado ou já existe.")

        # Mapeamento de classes
        self.label_map = {row['LabelName']: idx for idx,
                          row in self.class_names.iterrows()}

        print(f"Anotações carregadas: {self.annotations.shape[0]} imagens.")

        # Armazenar o processador de imagens
        self.image_processor = image_processor

    def __len__(self):
        return len(self.annotations)

    def __getitem__(self, idx):
        img_id = self.annotations.iloc[idx]['ImageID']
        img_path = os.path.join(self.img_dir, img_id + '.jpg')

        print(f"Processando ID da imagem: {img_id}")  # Log do ID da imagem

        # Verifique se a imagem existe antes de carregá-la
        if not os.path.exists(img_path):
            print(f"Imagem não encontrada: {img_path}")
            return None  # Retornar None se a imagem não for encontrada

        # Carregar imagem
        image = cv2.imread(img_path)
        if image is None:
            print(f"Falha ao carregar a imagem: {img_path}")
            return None

        # Converter a imagem para uint8 se o tipo for CV_64F
        if image.dtype == 'float64':
            image = (image * 255).astype('uint8')
        elif image.dtype != 'uint8':
            print(
                f"Tipo de imagem inesperado: {image.dtype}, convertendo para uint8.")
            # Converte para uint8 de maneira segura
            image = cv2.convertScaleAbs(image)

        # Log de carregamento da imagem
        print(f"Carregando imagem: {img_path}")

        # Obter anotações para a imagem atual
        img_annotations = self.annotations[self.annotations['ImageID'] == img_id]

        boxes = []
        labels = []

        for _, row in img_annotations.iterrows():
            xmin = row['XMin']
            ymin = row['YMin']
            xmax = row['XMax']
            ymax = row['YMax']
            label = row['LabelName']

            boxes.append([xmin, ymin, xmax, ymax])
            labels.append(self.label_map.get(label))

        # Verifique se não há anotações
        if not boxes or not labels:
            print(f"Não foram encontradas anotações para a imagem: {img_id}")
            return None  # Retornar None se não houver anotações

        # Processar a imagem
        try:
            processed_image, updated_annotations = self.image_processor.preprocess_image(
                image, img_annotations.to_dict(orient='records'))
        except Exception as e:
            print(f"Erro ao processar a imagem: {e}")
            return None

        # Log das anotações atualizadas
        print(f"Anotações atualizadas: {updated_annotations}")

        # Extrair as caixas atualizadas em formato de lista de listas
        updated_boxes = []
        for annotation in updated_annotations:
            if isinstance(annotation, dict):
                updated_boxes.append([
                    annotation['XMin'],
                    annotation['YMin'],
                    annotation['XMax'],
                    annotation['YMax']
                ])

        try:
            boxes_tensor = torch.tensor(updated_boxes, dtype=torch.float32)
        except Exception as e:
            print(f"Erro ao converter boxes: {e}")
            boxes_tensor = torch.empty((0, 4), dtype=torch.float32)

        labels_tensor = torch.tensor(labels, dtype=torch.int64)

        if self.transform:
            processed_image = self.transform(processed_image)

        # Salvar imagem processada e anotações no diretório de saída
        output_img_path = os.path.join(self.output_dir, f"{img_id}.jpg")
        success = cv2.imwrite(output_img_path, processed_image)
        if success:
            print(f"Imagem processada salva em: {output_img_path}")
        else:
            print(f"Falha ao salvar a imagem em: {output_img_path}")

        # Criar um arquivo de texto separado para cada imagem
        annotation_file_path = os.path.join(self.output_dir, f"{img_id}.txt")

        # Escrever anotações no arquivo de texto
        with open(annotation_file_path, 'w') as f:
            for box, label in zip(updated_boxes, labels):
                f.write(f"{label} {' '.join(map(str, box))}\n")

        print(f"Anotações salvas em: {annotation_file_path}")

        return processed_image, {'boxes': boxes_tensor, 'labels': labels_tensor}


# Exemplo de uso
if __name__ == "__main__":
    print("Iniciando o processamento...")
    try:
        img_dir = r"E:\\APS6\\NeuroVis-o\\backend\\uploads\\treino-img"
        ann_file = r"E:\\APS6\\NeuroVis-o\\backend\\uploads\\train-annotations-bbox.csv"
        class_file = r"E:\\APS6\\NeuroVis-o\\backend\\uploads\\class-descriptions-boxable.csv"

        # Altere para o diretório de Downloads do seu computador
        output_dir = r"C:\\Users\\Andressa\\Downloads"

        # Criar a instância do ImageProcessor
        image_processor = ImageProcessor()  # Ajuste os parâmetros conforme necessário

        dataset = OpenImagesDataset(
            img_dir, ann_file, class_file, output_dir, image_processor)

        # Processar cada item do dataset
        for i in range(len(dataset)):
            try:
                result = dataset[i]
                if result is None:
                    print(
                        f"Erro ao processar a imagem de índice {i}. Continuando para a próxima.")
                    continue  # Continuar para a próxima imagem
            except Exception as e:
                print(
                    f"Ocorreu um erro durante o processamento da imagem de índice {i}: {e}")
                continue

        print("Processamento concluído.")
    except Exception as e:
        print(f"Ocorreu um erro: {e}")
